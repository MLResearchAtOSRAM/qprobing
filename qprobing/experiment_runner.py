"""This module provides the main functionality for running quantitative probing experiments.

An experiment is set up as follows:
1) A linear probabilistic graphical model (pgm) is generated.
2) The pgm simulates data.
3) A task is generated by specifying the target causal effect, the effects to be used as probes and
   the hints about required edges for causal discovery.
4) A causal end-to-end analysis in run via cause2e on the data, with the goal of estimating the
   target causal effect. It uses the probes for validation and the hints for causal discovery.
5) The success of the analysis is evaluated:
   - How much does the target effect estimate deviate from the true effect?
   - How much does the causal discovery result deviate from the true causal graph?
   - Have the probes been estimated correctly?

The experiment is repeated multiple times and it is our goal to show that cause2e's results can be
trusted more if all the validation probes have been estimated correctly.
"""

import os
import pickle
from networkx import NetworkXError
from qprobing.data_generator import DataGenerator
from qprobing.task_preparator import TaskPreparator
from qprobing.analysis_runner import AnalysisRunner
from qprobing.analysis_evaluator import AnalysisEvaluator


class ExperimentRunner:
    """Main class for running the experiment. See module description for the included steps.

    Attributes:
        results_list: A list containing the results of the experiment runs.
    """

    def __init__(self, data_path):
        self._data_path = data_path  # TODO: Better to use one path for each run to allow parallel runs?
        self.results_list = []

    def run_experiments(self, n_experiments, data_generation_specs, seeds_list, task_specs, verbose=False,
                        keep_vm=True):
        """Runs multiple quantitative probing experiments.

        Args:
            n_experiments (int): The number of experiments to be run.
            data_generation_specs (dict): Parameters for the data generation.
            seeds_list (list): Contains seed dictionaries for each of the runs.
            task_specs (dict): Parameters for the task generation.
            verbose (bool, optional): Determines whether the result of each run is displayed. Defaults to False.
            keep_vm (bool, optional): Determines whether we want to keep the
                Java VM alive between runs. Defaults to True.
        """
        seeds_list = self._prepare_seeds_list(n_experiments, seeds_list)
        for i, seeds in enumerate(seeds_list):
            data_generation_specs['seeds'] = seeds
            if i == len(seeds_list) - 1:
                keep_vm = False
            self.run_experiment(data_generation_specs, task_specs, verbose, keep_vm)
            if i % 10 == 0:
                print(f"{i} experiments done.")

    def save_results(self, filename):
        """Saves the result list to a pkl file.

        Args:
            filename (string): The desired file name of the pkl.
        """
        with open(filename, 'wb') as f:
            pickle.dump(self.results_list, f, pickle.HIGHEST_PROTOCOL)

    def _prepare_seeds_list(self, n_experiments, seeds_list):
        if seeds_list:
            if len(seeds_list) != n_experiments:
                raise InvalidSeedsError("Number of seeds does not match number of experiments.")
            else:
                return seeds_list
        else:
            return [{}] * n_experiments
        # TODO: Should we also check the contents? An error in the last run would be annoying.

    def run_experiment(self, data_generation_specs, task_specs, verbose=True, keep_vm=True):
        """Runs a single quantitative probing experiment.

        Args:
            data_generation_specs (dict): Parameters for the data generation.
            task_specs (dict): Parameters for the task generation.
            verbose (bool, optional): Determines whether the result is displayed. Defaults to False.
            keep_vm (bool, optional): Determines whether we want to keep the Java VM alive. Defaults to True.
        """
        try:
            self._generate_data(**data_generation_specs)
            self._prepare_task(**task_specs)  # TODO: Allow seeds for this, too!
            self._run_analysis(keep_vm)
            self._evaluate_analysis(verbose)
            results = self._pack_results()
        except NetworkXError as e:
            results = e
        finally:
            self.results_list.append(results)
            os.remove(self._data_path)

    def _generate_data(self, n_vars, n_samples, p_edge, seeds, show):
        dag_seed, cpd_seed, simulation_seed = self._unpack_seeds(seeds)
        self.seeds = seeds
        self.data_generator = DataGenerator.from_scratch(n_vars, p_edge, dag_seed, show)
        self.data_generator.create_random_model(cpd_seed)
        self.data_generator.generate_data(n_samples, simulation_seed, self._data_path)

    def _unpack_seeds(self, seeds):
        seed_names = ['dag_seed', 'cpd_seed', 'simulation_seed']
        return tuple(self._get_seed(seeds, seed_name) for seed_name in seed_names)

    def _get_seed(self, seeds, seed_name):
        return seeds.get(seed_name, None)

    def _prepare_task(self, p_hint, p_probe, tolerance):
        self.task_preparator = TaskPreparator(self.data_generator.model, self.data_generator.nx_graph)
        self.task_preparator.prepare_task(p_hint, p_probe, tolerance)

    def _run_analysis(self, keep_vm=True):
        self.analysis_runner = AnalysisRunner.from_task_preparator(self._data_path, self.task_preparator)
        self.analysis_runner.run_analysis(keep_vm)
        self.learner = self.analysis_runner.learner

    def _evaluate_analysis(self, verbose):
        self.analysis_evaluator = AnalysisEvaluator.from_runner_and_preparator(
            self.analysis_runner,
            self.task_preparator
        )
        self.analysis_evaluator.evaluate_analysis(verbose)

    def _pack_results(self):
        return {
            'seeds': self.seeds,
            'evaluator': self.analysis_evaluator,
        }


class InvalidSeedsError(Exception):
    pass
